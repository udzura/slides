はい、承知いたしました。以下に音声ファイルの文字起こし結果を記載します。

---

えー、では発表を始めさせていただきます。
近藤がお送りします。
SmartHRのプロダクトエンジニアをしています。

今日のテーマは Wardite という、ピュア Ruby 製の Wasm の Gem です。

Wardite は Pure Ruby WebAssembly ランタイムです。
Wardite は `gem install Wardite` で簡単に動かすことができ、え、既存の Wasm バイナリを動作させることができます。
また、Gem とし、Gem なのでライブラリとして使うこともできて、Ruby のコードの中で Wasm ファイルを読み込んで動かすことも可能です。
ということで Wardite は Pure Ruby WebAssembly ランタイムです。

では、WebAssembly とは何か？ WebAssembly ランタイムとは何か？という話を改めてします。

WebAssembly とは、バイナリ形式の一種の命令セットアーキテクチャです。
元々は Web ブラウザの上で実行されることを目的としたものでしたが、近年は色々な環境で利用できるようになっています。
例えば、こういう C のコードを Wasm の形式のバイナリにコンパイルすると、ブラウザの上で動かすことができます。

で、WebAssembly はブラウザで動くものと皆様思っているかもしれませんが、どんなところでも現在では動くとされています。
え、クライアントの、え、コマンドラインツールに Wasm バイナリを渡して動かすことが可能です。
例えば、さらに言うと、例えば Wasm の実行環境をアプリケーションの中に組み込んで動かすこともできます。

WebAssembly の実行の流れは、最初にソースコードがあって、それを、それを、えー、コンパ、Wasm の専用のコンパイラでコンパイルしてあげると、Wasm のバイナリができます。
その Wasm のバイナリをランタイムで実行することで、やっとプログラムが動くという大きな流れがあります。

ということで WebAssembly ランタイムとは、え、既存、ある、事前に作っておいた Wasm のバイナリを実行するための環境ということができます。
そういう意味ではブラウザもランタイムと見なすことができますし、また Wasmtime、WasmEdge をはじめとした WebAssembly を動かすための、え、実装も、え、特別な実装も存在します。
さらに言えば、言語の内部に組み込んで実行するような実装も存在しており、往々にしてそういう実装は、その言語自体でピュアに、え、作られています。Go の WasmZero であったり、Swift の SwiftWasm が代表的なものです。

ということで Wardite は Pure Ruby で書かれています。
なので、Ruby で書かれているので、Ruby の中で WebAssembly を動かすことができる優れものです。
一応コマンドラインツールも別には用意していますが、Ruby の中でも動かせます。

Wardite の設計方針として、Ruby の標準ライブラリだけに依存させるというのをやっております。
また、RBS を全面的に採用して、え、型をしっかりつけて書いてあります。

Wardite は現在、WebAssembly Core Spec の実装は、ま、大体終わっており、WASI と呼ばれる、え、仕様の実装もしているので、え、Ruby Wasm の動作をさせることが一応できています。

さて、WebAssembly Core Spec とは何かというと、言いますと、WebAssembly の基本的な仕様のセットと言えます。
これはバイナリ形式やテキスト形式、命令セット、型システム、メモリ、その他の色々なモデルを定義したもので、ランタイムはこれらの仕様をちゃんと実装さえしていれば、ま、そのスペックに沿ったバイナリを動作させることができるというものです。
で、WASI や、まあ、いわゆるコンポーネントモデルのような仕様は、その Core Spec の上に成り立っています。

さて、その WASI は、次は WASI の説明ですが、これは WebAssembly System Interface と呼ばれるもので、
え、実は WebAssembly の Core Spec には OS とのやり取りの定義は存在しません。
なので、その OS と、OS や他の外部のシステムとのやり取りをする部分の API を WASI という形で別に定義しています。
P1 と P2 がありますが、ま、一般的には P1 を動かす、動かすことが多いので、まだまだ多いので、P1 を実装しています。

さて、Wardite の現状をお話したところで、なぜ Wardite を作ったかという話をします。
いくつか理由がありまして、まず Ruby で Wasm 言語への組み込み活用のユースケースを広げたいというものがあります。
あるいは、可搬性を高い実装が欲しい。例えば、Ruby が動いたらどこでも動くようなもの、あるいは、もしくは M Ruby でもちゃんと動くような実装が欲しいという気持ちもあります。
さらに言うと、Ruby 自体のパフォーマンスの、ま、テストの一環として、このような複雑なソフトウェアがあると嬉しいのではないかという気持ちもあります。
とはいえ、本音を話すと Just for Fun というところです。

で、元々テクノヒッピー（※？）さんの実装が先行してあったのですが、かなり前の（に）更新が止まっており、実装の保証も終わったので、ま、改めてやろうと思いました。

さて、そもそも WebAssembly に大きな、私は大きな可能性を感じていて、Ruby でその世界に触れられると嬉しいなと思っております。
WebAssembly にはいくつか可能性があります。
一つは言語アグノスティックな部分がとても興味深いなと思っています。
色々なコンパイル型の言語、Rust や Go や C++、C++ をはじめ、色々な言語で Wasm ターゲットをサポートしており、
また、C 言語が Wasm にコンパイルできる以上、C 言語で書かれた Ruby, Python, Lua, Perl といった言語も Wasm の上で動かすこと可能性、動かせる可能性があります。

さらに WebAssembly の Core Spec 自体もシンプルながら合理性をキープしているように私には思えて大変興味深いものです。
そして、そのシンプルさにもつながるんですが、WebAssembly は様々なアプリケーションに組み込んで実行することが可能です。
ランタイム自体が、ま、比較的小さいため、各環境に自分で実装して組み込むということができそうに思います。

例えば Go は、自分自身、Go 自身で書いた WasmZero という Wasm の実装がありますが、一方で、Go 自身も、Go 自体も Wasm にコンパイルすることができます。
なので、Go で作った Wasm の実装で Go の、Go で作った Wasm のバイナリを動かすことで、まあ、動的なロードを実現しています。
一般に Go 言語は C 言語の資産を使いづらいため、非常に安全な動的ロードの実現には、え、需要があります。

そして何度も言っていますが、ブラウザもまた Wasm ランタイムが組み込まれた環境と捉え直すのが正しいのかなと思っています。
なので、ま、こういったところを突き詰めていけば、まあ、Wasm は非常に言語アグノスティックな部分が強くて、
ま、色々なアプリケーションの中に Wasm を組み込んで、その Wasm のランタイムの上で動かすものはどんな言語で書いてもいいという、言語を上手に組み合わせる未来を想像、予感させてくれるなと思っています。

ま、その辺の概念図は Wasm Cloud という、え、OSS の概念図がそれらしいかなと思います。
この通りブロックを組み合わせたらアプリができるような未来が見えてくるかもしれません。

(Wasm の話は省略します。)

ということで、単純な、単純に JVM と比較されることもありますが、設計思想が違うなと思っており、え、
ま、た、単にブラウザで動くから価値があるというよりももっと面白いことができるんじゃないかと思っています。

さて、WebAssembly の可能性について語ったところで、Wardite を作った振り返りをしていこうかなと思います。

Wardite は開発の上でいくつかマイルストーンがありました。
最初のマイルストーンは、え、GorillaBook というものを移植して、え、Ruby で Hello World 動かしたところまでですね。
GorillaBook は、まあ、元々 Rust で WebAssembly の基本的な実装を学ぶための本として書かれた、Web の Web ブックなんですが、まあ、ちょうど勉強するタイミングがあったので、試しに書いてみたというのが始まりです。
元々 Rust の実装なので、それを RBS を全体的に使った Ruby で書けば、まあ、同じように書けるかなと思いました。

感想としては、あの、非常に良い本だなとは思ったんですが、やはり、ま、VM の全体の設計思想の理解というのはなかなか骨が折れました。
とはいえ、本自体に Rust の参考実装が添付されているようなものなので、大変助かりました。

で、GorillaBook の記述とほぼ似たような感じにはなってしまうんですが、少しだけは Wasm の中身を説明すると、
Wasm は、Wasm はまずバイナリフォーマットをパースしなきゃいけません。
と、とはいえバイナリフォーマットは、まあ非常に簡単なもので、冒頭にヘッダがあって、
実際、そこにヘッダにサイズが書かれていて、その後にセクションの中身が続いていくという感じのシンプルな、シンプルな、え、セクションの組み合わせであります。
ま、図にすると、こんな感じです。

で、バイナリさえパースできれば、あとは VM を書いていくだけなんですが、VM も基本的には無限ループというか、1 つ命令を取得して、その命令を実行して次の命令を取得するという風に、そのループを繰り返すだけで動く、動く、繰り返すのが VM の基本的な実装です。

逆に言うと、VM は簡単なんですが、あの、外界とのやり取り、出力というのは意外と難しくて、
出力をするためには WASI の `FD_write` という関数だけは実装しておかないといけないので、これ、これも実装しました。とはいえ本があったので、ものすごく難しいというわけではなかったです。

ということで Hello World は動きました。
Hello World はいつもとってもいいものですね。

続いて、Wasm Core Spec の基本的な命令をカバーしようと考えました。
そうですね。この時点で Ruby Wasm 動かしたいなという気持ちが少しだけありました。

Wasm の命令セットは基本的な範囲と拡張セットがあります。
基本的な範囲は、ま、基本的な範囲含めて、ま、Core Spec にどの範囲がどれというのは書いてあるのですが、え、ま、拡張セットというものが特別にあって、ま、GC に関するところとか、あとは SIMD を使う命令とか色々、ま、あと、えっと、コンカレンシーとかいくつかありますが、
今回は基本的な部分だけをやりました。
基本的な部分は、この Table、Opcode Table というサイトを参照するとこの辺りです。

で、苦労した点は、ま、数が多かったのが大変でした。当然ですが。えっと、基本的な部分だけとはいえ、命令の数でいうと 192 個を実装しました。ま、そうは言っても VM というものは、1 つ 1 つ の命令は小さいものなので、ま、小さいことをたくさん頑張ったという感じです。

で、一応 Wasm には数値の方が 4 つあります。
i32, i64, f32, f64。ま、インテジャーとフロートですね。
この 4 つについてそれぞれ、あの、同じような命令が存在していたりするので、Add とか、ま、Add とか Sub とか。
そういったところは共通のものは、あの、自動、ジェネレーターを作ってまとめて作るようにしました。
で、意外とそういう、あと変換系の命令もですね。そういう命令が 167 個ぐらいあった、あるらしいです。
で、まあ、そんな本当に素朴なテンプレートを作って `Rake generate` しています。

はい。で、そうしていたら一応一通りの命令はカバーできたので、実践的なプログラムを動かそうと考えました。
別のプロジェクトで作っていた Rust のグレースケール化のプログラムを動かしてみました。
そしたら動きませんでした。

ということで、これをデバッグする、え、日々が始まります。

ちなみにグレースケールのプログラムは、ま、ざっくり言うと Base64、いわゆるデータ URL 形式のデータを渡すと、それを Base64 にデコードして、
デコードしたデータが PNG の画像なので、それを、え、ピクセルに直して、グレースケールに変換して、また PNG 画像に戻して、最後にまた、え、Base64 でエンコードしてテキストで戻すという、そういう感じのことをしています。

最初に躓いていたところは、ま、メモリ確保の処理が正しく動いていなかったんですね。ただ、これ修正したところは 1 行なんですが、ここにたどり着くまでにブラウザで、ブラウザでそのグレースケールの Wasm を動かして、ブレークポイントを仕込んで、あの、Wardite ではここ、ここが落ちるようなブレークポイントを、えー、ブラウザ側に仕込んで、処理の違いを変数をとか処理を見、見るみたいな大変なことをしていましたが、あまり記憶がありません。はい。

で、メモリ周りは直ったんですが、まだ動かないところがあって、
というのも Rust はパニック、Rust のパニックは Wasm の `Unreachable` という命令に変換されてしまい、`Unreachable` はとにかくここに到達したらエラーという命令なので、ちょっとよく分からなくて、
パニックされるとこは、のはやめて、もうエラーの文字列をそのまま返却するようにしてみました。
それでエラーの文字列が分かって、
なんかこういう "Corrupted deflate stream" と書かれていて、あの、エラーの ID が分かりました。
なので Rust 側の処理を眺めてみました。
なるほど分からんという、とこでした。ま、ここは要するに Deflate の圧縮を解いているところ
だとは分かるんですね、関数の名前で。とはいえ Deflate のアルゴリズムを勉強するところからか？と思ってちょっと辛かったんですが、
コードを眺めた感じだと、ビットシフト演算が多用されているっていうのだけは分かったので、じゃあ一旦ビットシフト演算とかそういう数値命令が正しいかどうかを確認しようと思いました。

で、それを、え、i32 とか数値系の命令が正しいことは、え、ちゃんと公式のテストケースがあるので、え、それを実行すれば確認できます。
具体的には、まあ、具体的なやり方は、え、紹介している記事を見ていただきたいんですが、`Wat2json` というテストケースをまとめて生成するツールを用いて、ま、その必要なものを生成してできるので、それを Ruby を使ってぐるぐる実行させていけば OK という感じです。
まあ、ちょっと色々書いたんですが、コードを見れば分かるかなと思うんですけど、JSON、テストケースの JSON が生成されるのでパースして、それをぐるぐる回して Wardite で、Wardite で Wasm を呼び込ませて、値が合っているか見ると。シンプルですね。

これを、ま、`Test::Unit` の形式になるようにちょっと書き換えてぐるぐる回してみました。で、実際ビットシフト系の命令中心に結構壊れている、特にオーバーフローとかの処理が甘かったりしたので、
そういうところを修正したら、正常系は全部通る、通るようになりました。
結果としてグレースケールもちゃんと動きました。
ちゃんと動いてますよね？なんか。多分ちゃんと動きました。はい。

ということで、もっと実用的なものを動かそうという機運が高まったので、Ruby Wasm も動かしてみます。
Ruby Wasm を動かすには、命令の他にも WASI のサポートがちゃんと必要です。
で、Ruby Wasm は特にオプションなしでビルドすると 37 個の関数、37 個の関数が必要となる。37 個の WASI の関数が必要となります。
で、これら の関数をまとめて 1 つのクラスに実装してインポートできるように、え、していきました。
ま、1 つ関数、1 つ関数の実装の例をあげると、`ClockTime.get` は、ま、要するに Ruby で言えば `Time.now` をラップするだけのメソッドです。なんか違和感があるコードかもしれないんですけど、え、要するに WASI、Wasm の世界と OS の世界を Ruby で繋いでるだけなので、本当になんか愚直なコードがどんどん出てきます。

ということで、この、これら の関数を地道に実装していくという感じになったわけです。
で、作戦としては、ひたすら `loop do` して、Ruby Wasm をまず起動させようとして、「何々という関数がなくて動かない」って言われるので、それを実装するというのを繰り返しました。
で、ま、ここに書いてあるのは本当に ARGV の取得とか、現在時刻、乱数、環境変数みたいな本当に基本的なシステムの、え、情報を取る関数を実装していきました。
で、最低限実装したんですけど、最後の最後でやっぱり if ブロック、if の実装を間違えてはまっていて、Wasm Tools で Wat 化して睨めっこして気づくみたいなことがありました。
ま、これだけのコミットでめちゃくちゃはまっていたりします。

で、最終的に Ruby Wasm のバージョンが動くようになりました。
めでたし、めでたし。

この時点では、え、Ruby の C 実装の Core ライブラリは動くので、`times` とかは、ま、なんとか動く。
一方で、ま、書いてある通り、ファイルシステムを認識できないんですね。この、この時点では。なので、`require` がちゃんと動いてなくて、ロードの警告は出ます。
なので `require` をちゃんと動かしたい。そのために Wardite にファイルシステムをまとめて認識させたいと考えました。

ということでファイルシステムを実装してみます。
最初はだから雑に `Pathname.open` という関数があるので、ファイルを開させようとしましたが、
そもそも呼ばれないんですね、この関数は。
なぜか？なぜかというと、ちょっと Preopens という仕組みをちゃんと実装しなきゃいけなかったんです。

で、WASI SDK の、ま、Lib C の実装とかを眺めるとですね、まあ、C 言語で言うとこんな感じで、
なんか、ま、分からないと思うんで飛ばすと、
え、日本語で説明すると、あの、Wasm ランタイムは普通に起動すると、WASI を有効にしていても母艦環境のファイルシステムには一切触れることができない、できないようにできています。
で、Wasm ランタイムを起動する際に、まあ、ファイルディスクリプタの 3 番以降に母艦環境と共有したいファイルシステムの情報を、え、ま、特定の形式で突っ込んで渡してあげる必要があります。この仕組みを Preopens とか呼んでいるように思います。

で、WASI SDK の場合は `PopulatePreopens` という関数が、えっと、なんか起動した最初か、まあ、
ファイルオープンの最初に呼ばれます。で、FD 3 番から順番に、え、検査をして、その母艦環境と共有した情報を都度都度登録しています。
だから `Pathname.open` などの関数は Preopen 環境が搭載、登録されていないと、そもそも呼ばれないという実装になっていました。そうですね、EBadF を返すみたいな感じですね。はい。

まあ、実際 C 言語の、Lib C、WASI SDK の Lib C を見ると Preopens をぐるぐる回しているのが分かります。
ということで、このあたりの関数をちゃんと実装し、まあ、いくつか必要な、特に ReadDir とか辛かったんですけど、まあ、なんとか実装して、
え、ま、大体 1 週間ぐらい前にロードの警告なしで通常の Ruby が起動しました。はい。
警告出てなくて Gem、`Defined Gem` がちゃんとコンスタントになっていますよね。

ということで、めでたしめでたしというところで、あの、
僕の環境では、この RubyGems を全部初期化するのに 68 秒かかるんですね。なので、まあ、ちょっとパフォーマンスで考えていることの話を最後にしようと思います。

一応ここまで起動のデモだけ少しやりますね。
あの、`disable_gems` しないとでやれば、一応 10 秒ぐらいでは立ち上がると思うんですけど。

(起動待ち)

はい、ありがとうございます。

最後にパフォーマンスとの、パフォーマンス計測の話をすると、あの、まあ、ま、まだまだ途中の話ではあるんですけど、参考になるかなと思ってします。
一応計測の前提としては、基本的にはグレースケール処理を、え、動かして行ってたので、数値計算に偏っているかなと思います。
他のベンチ、まあ、断っていない限りはそれを使ってます。で、ソフトウェアのバージョンは書いてある通りです。
ま、Mac の、M1 Mac を使ってます。M3 か、はい。

ブロックジャンプの改善の話からすると、あの、WebAssembly のジャンプ系の命令ってちょっと変わっていて、
命令がオフセットを持ってるんじゃなくて、命令に来たら、えっと、エンドの位置を動的に計算するみたいな実装しているんですね。If とか、If, Block, Loop っていうのはそれに当たるんですけど。
で、ところで Ruby プロフで一番最初の実装を計測したところ、この `FetchOpsWhileEnd` というメソッドがめちゃくちゃ上に来てました。これは何しているかって言うと、If や Block や Loop の命令に来るたびに、対応する End の位置を、あの、いちいち動的に命令を、命令を、あの、ピークして計算していたんですね。
これが、なんか の関数に入っていたりして何回も呼ばれたら、まあ、それは遅いんですね。ということで、
命令は一旦、ま、JIT とかは考えないことにして、動的に書き換わることはないという前提で、End の位置は事前に計算させています。まあ、一度命令をパースしてからもう一回命令をぐるっと回して、再計算させてキャッシュで持たせています。
それで実行時間は、あの、グレースケールだと 43% 減りました。ま、さすがにこれぐらいはやっとかないとなっていう感じです。

で、これが格闘中なんですけど、インスタンス生成のところを、え、問題だなと思っています。
プロフで Wardite のボトルネックを計測しました。
出てきたのが `RubyVM#setivar` とか、あの、`Class#new_instance_pass` とかなんちゃらかんちゃら。この辺りがよく出てくるんですね。
つまりインスタンスを作りまくってるので遅いんですよ。
Wardite の内部の i32 とか i64 とかってこういう実装してるので、なんか素朴に。
これを、これを、作りまくってて遅い。
どんぐらい作ってるかっていうのをちょっとトレースポイントでさっくり計測してみました。まあ、グレースケールの例です。で、グレースケール、ただのちっちゃい画像のグレースケールさせてるだけなのに、i32 は 1880 万個作って、
これが 1 ミリ秒、1 個 1 ミリ秒としても、なんかすごい時間かかっちゃうよねって感じです。はい。

で、ちょっとだけ試したのが、i32 と言って特定の単位インスタンスが多いだろうなって思ってて、
それを、まあ、簡単にメモ化してみました。だから 0 から 64 と -1 だけメモ化したりしてみました。それで一応計測したら 1 秒だけ、1 秒ぐらいは変わってます。なので、
ま、ま、これは入れてますが、本当は i32 とかそういう値はインテジャーの即値を使うべきだろうなと思っていますが、
ま、設計が大幅に変わるので ToDo としています。

で、一応 Ruby Wasm の起動の所要時間をざっくり説明すると、ま、まずバイナリをパースするのも遅いんですね。全体に対してこれぐらいかかってます。で、Disable Gems した場、そうでない場合でこんぐらい違うんで、じゃあ Disable Gems が何しているかって言うと、ま、主に WASI の関数も遅いんですよ。だから WASI の関数呼び出しの所要時間だけを、え、抜き出したらこんな感じです。ま、ただ計測のためのオーバーヘッドもかかってるっていうのはご留意ください。本当にざっくりした中身だけです。はい。

で、一応 YJIT 効くの？って話なんですけど、めちゃくちゃ効きます。めちゃくちゃ効くんで、基本的にさっきのベンチは全部 YJIT 効いてます。はい。
で、YJIT はどれぐらい効くかの話をしとくと、あの、アームの環境です。
アームの環境で 3.3 だとこれぐらいで、3.4 だとすごくって、これぐらい。3.3 よりも効果が大きいです。いつもありがとうございます。
で、3.5 だとこんな感じでした。
って感じで、ま、YJIT はえっと、ま、有効になるような感じでつく、動かせます。

はい。ということで色々話したんですが、まあ、
ちょっと終わり、まとめといつつも、なんか言いたいことは全部言っちゃ、言っちゃってるので、
一言だけ言及をすると、コンポーネントモデルという、ま、次世代の Wasm のフォーマットみたいなのがあるんですけど、
これにも対応したいとは思ってます。あの、対応したいとは思ってるというだけなんですが、えっと、認識はしているので、
やりたいし、プルリクが来たら、あの、対応したりすると思います。
その他はパフォーマンスを中心に地道な改善をしていきたい所存です。
はい。なんか Wasm ランタイムを Ruby で動かすってなんか、なかなか
まだまだクレイジーな部分があるので、
まあ、でも遊びでもいいから使ってみたら、いろんな用途が思いつくかもしれないんで、ぜひぜひ
え、使ってみてください。

え、ご清聴ありがとうございました。

---

以上です。ご確認いただき、もし修正が必要な箇所があればお申し付けください。